pub(crate) mod constant;
pub(crate) mod enumeration;
pub(crate) mod module;
pub(crate) mod table;

use crate::*;
use crate::generator::module::EntityEntry;
use self::constant::ConstantEntry;
use self::enumeration::EnumerationEntry;
use self::module::ModuleEntry;
use self::table::TableEntry;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::fs::File;
use std::io::{BufWriter, Write};

const TAB: &str = "    ";
const GENERATED_FILE_WARNING: &str = "// This file is @generated by data-generator, DO NOT EDIT MANUALLY.";
const MODULE_FILENAME_PREFIX: &str = "spire.data";

#[derive(Debug)]
pub struct Generator {
    pub config: Config,

    pub modules: Vec<ModuleEntry>,
    pub tables: Vec<TableEntry>,
    pub enumerations: Vec<EnumerationEntry>,
    pub constants: Vec<ConstantEntry>,

    pub names: HashSet<String>,
    pub table_indices: HashMap<String, usize>,
    pub table_hierarchies: HashMap<usize, Vec<usize>>,
}

impl Generator {
    pub fn new(config: Config) -> Self {
        Self {
            config,

            modules: Vec::new(),
            tables: Vec::new(),
            enumerations: Vec::new(),
            constants: Vec::new(),

            names: HashSet::new(),
            table_indices: HashMap::new(),
            table_hierarchies: HashMap::new(),
        }
    }

    pub fn collect(&mut self) -> Result<(), Error> {
        println!("Collecting...");

        let base_module = ModuleEntry::new(Name::new("", Vec::new()));
        let mut next_modules = vec![base_module];

        while let Some(mut module) = next_modules.pop() {
            let child_modules = self.collect_module(&mut module)?;

            for i in 0..child_modules.len() {
                module
                    .entries
                    .push(EntityEntry::ModuleIndex(self.modules.len() + i + 1));
            }

            next_modules.extend(child_modules);
            self.modules.push(module);
        }

        self.build_table_hierarchies()?;

        Ok(())
    }

    pub fn generate(&self) -> Result<(), Error> {
        println!("Generating...");

        fs::create_dir_all(&self.config.src_gen_dir)?;

        for module in &self.modules {
            let filename = {
                let mut namespace = vec![MODULE_FILENAME_PREFIX.to_string()];
                namespace.extend(module.name.namespace.clone());
                format!("{}.rs", namespace.join("."))
            };
            println!("Generating {}", filename);

            let file = File::create(self.config.src_gen_dir.join(filename))?;
            let mut writer = BufWriter::new(file);

            write!(writer,
r#"{GENERATED_FILE_WARNING}
use crate::{{error::*, link::*, parse::*}};
use std::collections::HashMap;
use std::io::Write;
use std::mem::MaybeUninit;
use tokio::sync::Mutex;
"#)?;
            
            // If base module, generate initialize function.
            if module.name.name == "" {
                self.generate_initialize(&mut writer)?;
            }

            for entry in &module.entries {
                match entry {
                    EntityEntry::ModuleIndex(_) => {},
                    EntityEntry::TableIndex(index) => self.generate_table(
                        &self.tables[*index],
                        &mut writer,
                    )?,
                    EntityEntry::EnumerationIndex(index) => self.generate_enumeration(
                        &self.enumerations[*index],
                        &mut writer,
                    )?,
                    EntityEntry::ConstantIndex(index) => self.generate_constant(
                        &self.constants[*index],
                        &mut writer,
                    )?,
                }
            }

            writer.flush()?;
        }

        Ok(())
    }

    pub fn register_type(&mut self, type_name: &str) -> Result<(), Error> {
        if self.names.contains(type_name) {
            return Err(Error::NamespaceCollision(type_name.to_owned()));
        }

        self.names.insert(type_name.to_owned());
        Ok(())
    }

    pub fn is_target(&self, target: Target) -> bool {
        target != Target::None && (target == self.config.target || target == Target::All)
    }

    fn build_table_hierarchies(&mut self) -> Result<(), Error> {
        for (index, _) in self.tables.iter().enumerate() {
            self.table_hierarchies.insert(index, Vec::new());
        }

        for (index, table) in self.tables.iter().enumerate() {
            let extend = match table.schema.schematic().extend() {
                Some(extend) => extend,
                None => continue,
            };

            self.table_hierarchies
                .get_mut(&self.table_indices[extend])
                .unwrap()
                .push(index);
        }

        Ok(())
    }
    
    fn get_parent_table(&self, extend: &Option<String>) -> Option<&TableEntry> {
        let parent = match extend {
            Some(parent) => parent,
            None => return None,
        };
        
        Some(&self.tables[self.table_indices[parent]])
    }
}
